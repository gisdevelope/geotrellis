# Index

This document covers the concepts and practice behind creating a custom data adapter and index.

## DataTypeAdapter

GeoWave [DataTypeAdapter](https://locationtech.github.io/geowave/devguide.html#adapters) is responsible for

* Encoding/Decoding records
* Extracting index values from records
* Extracting unique data id from records


In GeoWave, `Adapter` is an object that can extract index and data values from the input entry and can
also write / read data type to / from the data base. Each adapter has a list of `Field Handler`s.

`Field handler` is a special function that extracts values from the entry. For example, it can extract `Extent` or `Time` from a `MultibandGeoTiff`.

Each `Adapter` has a name, that should be unique per Cassandra `namespace`.
In this project all adapters extend [`GeoTrellisDataAdapter`] which implements some of the common behavior.

### DataTypeAdapter Lifetime

In order to use the adapter it needs to be bound with one or more instances of an index.

```scala
val geowaveDataStore: DataStore = DataStoreFactory.createDataStore(
  new CassandraRequiredOptions("cassandraHost", "my_keyspace", new CassandraOptions()))

// Create an adapter that can extract Spatial, Temporal and Elevation values from GeoTiff for indexing.
// The adapter also has a name ("GeoTiffAdapterSpec"), which should be unique in the Cassandra namespace.
val dataTypeAdapter = new GeoTiffAdapater("GeoTiffTiles".typeName)
val index: Index = new SpatialDimensionalityTypeProvider.SpatialIndexBuilder().createIndex

// Add the newly constructed adapter to the data store. The adapter along with all handlers, primitives,
// and the index, will be serialized and stored in the DB.
dataStore.addType(adapter, index)

val writer = dataStore.createWriter[GeoTiff[MultibandTile]]("GeoTiffTiles")
val tiff: GeoTiff[MultibandTile] = ???
writer.write(tiff)
writer.close()
```

During the call to `addType` method the adapter and provided indices are serialized and stored to the database.
From that point on they are functionally immutable. Both readers and writers are created from the type name.
That process reads the serialized adapter from the database and uses it to produce reader/writer instances.

Each index is associated with a table in cassandra. Writing to given type will result in duplicate records being written to each index table.
During query the appropriate table will be selected based on query parameters.

When multiple types are using the same index they are written to the same table.
That is a single GeoWave table is able to contain data from multiple adapters.

#### The internal DB structure

The structures in this section are generated by the command above.
As the result, the following structure in Cassandra would be generated:

```sh
docker-compose exec cassandra cqlsh
```

```
cqlsh> describe tables;

Keyspace my_keyspace
---------------------------
index_geowave_metadata    sp_temp_dpt_idx_balanced_year_2147483647
aim_geowave_metadata      internal_adapter_geowave_metadata
adapter_geowave_metadata
```

- `index_geowave_metadata` - stores `Index` instances
- `aim_geowave_metadata` - stores `Adapter` to `Index` mapping
- `adapter_geowave_metadata` - stores `Adapter` instances
- `sp_temp_dpt_idx_balanced_year_2147483647` - a table created for the index; all records that are indexed using this index would be placed into this table.
- `internal_adapter_geowave_metadata` - stores `Adapter Internal Adapter Mappings` within an Cassandra table for GeoWave metadata

The conclusion:

1. Index is unique and is created based on the input options by default. It has a table that is associated with this index (`sp_temp_dpt_idx_balanced_year_2147483647`).

2. The default index name is generated based on the input index configuration. For example, `sp_temp_dpt_idx_balanced_year_2147483647` means a spatial temporal index with a per year binning and a max elevation = 2147483647). It is possible to override the default name with any custom unique string.

3. Both Index and Adapter instances are serialized and stored in the DB. This is a design constraint from GeoWave which forces a single adapter and index per table. Once the index table is created it cannot be changed.

4. An `Adapter` can be associated with more than one `Index`. `Adapter Name` refers to both an _adapter_ and all _indexes it can operate with_.

5. Adapter and all the indices related to it are called `type` in GeoWave.

6. All data ingested using different `adapters` but the _same_ `index` would be stored in the same table.

Note that in the following sections of this document, `typeName` is the adapter name which references both the data type and all the indices related to it.

The `sp_temp_dpt_idx_balanced_year_2147483647` table schema looks like this:

```
partition | adapter_id | data_id | .. other configurable index fields .. | value
```

Here `partition` means a Space Filling Curve (SFC) index, `adapter_id` means the adapter id,
`data_id` is the data identifier that is required to perform a secondary filtering in case
the SFC is not precise enough, and `value` is the actual value stored.

### TypeName

Each `DataTypeAdapter` instance is identified by its `TypeName`.
As seen above a type actually refers to combination of adapter, indices and their configuration.
The name used is purely an identifier and does not have any restrictions.

### DataId

`DataTypeAdapter` must be able to produce a data id as `Array[Byte]` for records it supports.
This data id must be unique per-type, per-table.
While writing records to cassandra with same id will produce additional rows they will be de-duplicated during query time.

### Field Handlers

In order to for your data type to be indexed there has to be a way to extract the position of the record with regard to the index dimensions, field handlers provide this functionality.
The matching happens by field name. Each extracted coordinate is stored in `CommonIndexModel` and need not be stored again as part of the field encoding if it is not useful.

### PersistableRegistrySpi

Each adapter and each handler must be registered with GeoWave `PersistableRegistrySpi`.
Failure to do so will result in various null pointer exceptions when reading or writing with that adapter.
All instances are persisted when first registered and are subsequently loaded from there each time a reader/writer is created.


## Index

GeoWave [indices](https://locationtech.github.io/geowave/devguide.html#indices) provide the core mechanism to store and query multidimensional data. The index implementation is abstracted from `DataTypeAdapter` such that it is possible to use single implementation of an index with multiple data types.

### DimensionalityTypeProviderSpi

When creating a new index you should implement `DimensionalityTypeProviderSpi` interface.
This interface provides both the plugin discoverability for index as well as a way to configure it.
A range of functionality and configuration is provided.
Best way to dive into it is to inspect the `createIndex` method in existing implementations of this SPI.

See: `SphericalIndexTypeProvider.scala`

### NumericDimensionDefinition

An index must provide a list of dimensions that it will range over.
For most "extra" dimensions `BasicDimensionDefinition` is sufficient.

See: `ElevationDefinition.scala`

### NumericDimensionField

DimensionField is what provides the `IndexModel` with a way to read/write field values, it relies on `DimensionDefinition`.
Critically it is identified by its `fieldName`. The field name must match the field name of data type adapter field handler.
This is the core binding between implementations of `DataTypeAdapter` and `Index`.
The exact mechanism can be seen in the implementation of `GeoTrellisDataAdapter.encode`.

See: `ElevationField.scala`

### Name

Index name must include enough information to avoid conflicts in its configuration.
Index configuration allows configuring things like dimension precision and value range.
These parameters effect the translation of dimension field values to their SFC encoded values.
Note that SFC values across different parameter values are not comparable.
In order to avid such conflicts the index name is used as the table name.

### Options

`DimensionalityTypeProviderSpi` is specified in conjunction with `CommonSpatialOptions`.
These serve double duty as command line option parser for GeoWave CLI, but are usable in other context.
Existing spatial and temporal indices have wealth of configurations that should be explored by the user.

See: [CommonIndexOptions](https://github.com/locationtech/geowave/blob/v1.0.0/core/geotime/src/main/java/org/locationtech/geowave/core/geotime/ingest/CommonSpatialOptions.java)
